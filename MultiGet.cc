
#include <fstream>
#include <curl/curl.h>
#include "utility.h"

using namespace std;

#define defaultChunkSize    1000000
#define defaultDownloadSize 4000000
#define defaultChunkNumber  4
#define kMAXChunkNumber 1000
#define kAcceptableHTTPResponseCode 206

/*Only uncomment if you want to see all the DEBUG messages*/
//#define DEBUG

/*
This function sets up the characteristics of a request. It specifies the url,
http_version and the range of bytes that are to be downloaded in the 
corresponding request. It also specifies where the received data should be 
written (inside a buffer named out). The buffer will be written to the output 
file later.
*/
void setup(CURL *hnd, int num, string input_url, int low_range, int high_range, 
           stringstream  &out) 
{
  curl_easy_setopt(hnd, CURLOPT_URL, input_url.c_str());
  curl_easy_setopt(hnd, CURLOPT_WRITEFUNCTION, write_data);
  curl_easy_setopt(hnd, CURLOPT_WRITEDATA, &out);
  string range = "Range: bytes=" + NumberToString( low_range )  + '-' +
                  NumberToString( high_range );
#ifdef DEBUG
  printf(" second .........range ========= %s\n", range.c_str());
  curl_easy_setopt(hnd, CURLOPT_VERBOSE, 1L);
#endif
  curl_slist *list = NULL;
  list = curl_slist_append(list, range.c_str());
  curl_easy_setopt(hnd, CURLOPT_HTTPHEADER, list);
  curl_easy_setopt(hnd, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_2_0);
}

/*
This function writes the data stored in the buffer (data[]) to the 
output_file_name. The status array specifies the result of each request, i.e., 
the http response code corresponding to each request. Only the data for those
request that are completed successfully will be written to the output file.
*/
int WriteDataToFile(stringstream data[], int status[], int num_chunks, 
                    string output_file_name) 
{
  ofstream myfile;
  myfile.open(output_file_name.c_str());
  for (int i=0; i<num_chunks; i++) {
#ifdef DEBUG
    printf("..................status[ %d ] ==  %d\n", i, status[i]); 
#endif
    if (status[i] == kAcceptableHTTPResponseCode) {
      myfile << data[i].str();
    }
  }
  myfile.close();
}

/*
This function downloads the request in a synchronous way. Corresponding
to every chunk, it creates a curl request. The request are stored in an
array (CURL*). The http response code corresponding to each request will
be store in an array (status array) which will be used for writing data 
to the output file.
*/
int DownloadSynchronous(string url, int num_chunks, int chunk_size, 
                        string output_file_name)
{
#ifdef DEBUG
  printf(" num of chunks : %d URL is %s\n", num_chunks, url.c_str());
#endif
  CURL *easy[kMAXChunkNumber];

  /*The data for each transfer will be stored in this variable*/
  stringstream resultData[num_chunks]; 

  int status [num_chunks];
  int low_range = 0, high_range = 0;

  for (int i = 0; i < num_chunks; i++) {
    easy[i] = curl_easy_init();
    high_range = chunk_size * (i+1);
    setup(easy[i], i, url, low_range, high_range, resultData[i]);
#ifdef DEBUG
    printf("i = %d  lowrange= %d  high_range= %d", i, low_range, high_range);
#endif
    low_range = high_range;
    CURLcode res = curl_easy_perform(easy[i]);
    if (res != CURLE_OK) {
      fprintf(stderr, "curl_easy_perform() failed: %s\n", curl_easy_strerror(res));
    }
    long http_code = 0;
    curl_easy_getinfo(easy[i], CURLINFO_RESPONSE_CODE, &http_code);
  
#ifdef DEBUG
    printf("====HTTP     CODE =============  %ld\n", http_code);
#endif
    status[i] = http_code;
    WriteDataToFile(resultData, status, num_chunks, output_file_name);
    curl_easy_cleanup(easy[i]);
  }
}

/*
This function checks different requests in a parallel download to see how each
one went and what is the corresponding http response code. It reads the messages
generated by the requests performed on the multi interface. First it needs to 
figure out which request a message belongs to, therefore it find the index of the
request in the array of requests(easyindex). Then it stores the http response 
code of each request in the status array. The status array will be used for 
writing data to the file; i.e., only the result of successful requests will be 
written to the file.
*/
void check_multi_info(CURL **easyindex, CURLM *multi, int num_chunks, int *status) 
{
  CURLMsg *msg;
  int msgs_left;
  CURL *easy;
  CURLcode res;
  do {
    msg = curl_multi_info_read(multi, &msgs_left);

    if ( msg && (msg->msg == CURLMSG_DONE) ) {
      int idx, found = 0;

      // Find out which request this message is about 
      for (idx = 0; idx < num_chunks; idx++) {
        found = (msg->easy_handle == easyindex[idx]);
        if (found)
          break;
      }
      long http_code = 0;
      curl_easy_getinfo(msg->easy_handle, CURLINFO_RESPONSE_CODE, &http_code);
      status[idx] = http_code;
#ifdef DEBUG
      printf("=================%p %d  %ld\n", easy, idx, http_code);
#endif
    }
  } while (msg);
}

/*
The following function performs the parallel download by using multi_interface
API of libcurl library. It takes the url, number of chuncks and size chunks as
input and writes the data received from the sever in a buffer (resultDATA). The
data will be written to the output_file_name later (by calling WriteDataToFile ).
*/
int DownloadParallel(string url, int num_chunks, int chunk_size, 
                     string output_file_name)
{ 
#ifdef DEBUG
  printf(" num of chunks : %d URL is %s\n", num_chunks, url.c_str());
#endif
  CURL *easy[kMAXChunkNumber];
  CURLM *multi_handle;

  stringstream resultData[num_chunks];
  int status[num_chunks];
  int low_range = 0, high_range = 0;

  int still_running; /* keep number of running handles */
  multi_handle = curl_multi_init();
  for (int i = 0; i < num_chunks; i++) {
    easy[i] = curl_easy_init();
    high_range = chunk_size * (i+1);
    setup(easy[i], i, url, low_range, high_range, resultData[i]);
#ifdef DEBUG
    printf("i = %d  lowrange= %d  high_range= %d", i, low_range, high_range);
#endif
    low_range = high_range;
    curl_multi_add_handle(multi_handle, easy[i]);
  }

    /*
    Starting to perform asynchronous download of data by calling 
    curl_multi_perform which is a non-blocking function. 
    */
    curl_multi_perform(multi_handle, &still_running);

    /*
    The curl_multi_perform function needs to be called until all requests are 
    completed. This is done inside a loop. Whenever a request gets completed,
    the number of requests (still_running) will be reduced by one.
    */
    do {
          CURLMcode res = curl_multi_perform(multi_handle, &still_running);
    } while(still_running);

     check_multi_info(easy, multi_handle, num_chunks, status);

    /*This function writes the output of each request to the final output file*/
    WriteDataToFile(resultData, status, num_chunks, output_file_name);

    curl_multi_cleanup(multi_handle);

    for(int i = 0; i < num_chunks; i++)
      curl_easy_cleanup(easy[i]);
  
  return 0;
}

int main(int argc, char **argv)
{
  string url;
  int chunk_size = defaultChunkSize;
  int totalDownloadSize = defaultDownloadSize;
  int num_chunks = defaultChunkNumber;
  int parallel = 0;
  string output_file_name("outputfile");

  readArgs(argc, argv, url, num_chunks, chunk_size, totalDownloadSize, 
           parallel, output_file_name);

  if (!chunk_size)
    chunk_size = defaultChunkSize;

  if ( (!num_chunks) || (num_chunks > kMAXChunkNumber) ) 
    num_chunks = defaultChunkNumber;

  if (totalDownloadSize != defaultDownloadSize)
  	chunk_size = totalDownloadSize / num_chunks;

  if (num_chunks*chunk_size != totalDownloadSize) {
    chunk_size = totalDownloadSize/num_chunks;
  }
  printf("\nnumber-of-chunks:%d ,  chunk-size:%d Bytes, total-download-size:%d Bytes\n", num_chunks, 
         chunk_size, totalDownloadSize);

  if (parallel == 1) {
    printf("performing PARALLEL download\n");
    DownloadParallel(url, num_chunks, chunk_size, output_file_name);
  }  
  else {
    printf("performing SYNCHRONOUS download\n");
    DownloadSynchronous(url, num_chunks, chunk_size, output_file_name);
  }
  printf("\ndone.\n");
  return 0;
}
